//
//  CameraManager.m
//  CameraM
//
//  Created by é©¬èªèª on 2025/9/18.
//

#import "CameraManager.h"
#import "../Models/CMCameraLensOption.h"
#import "../Services/CMLocationService.h"
#import "../Services/CMImageProcessor.h"
#import "../Services/CMFormatManager.h"
#import "../Services/CMDeviceManager.h"
#import "../Services/CMMetadataEnricher.h"
#import "../Services/CMOrientationManager.h"
#import <CoreLocation/CoreLocation.h>
#import <CoreMotion/CoreMotion.h>
#import <ImageIO/ImageIO.h>
#import <Photos/Photos.h>
#import <float.h>
#import <math.h>

@interface CameraManager () <AVCapturePhotoCaptureDelegate, CLLocationManagerDelegate, CMLocationServiceDelegate, CMOrientationManagerDelegate>

// AVFoundation æ ¸å¿ƒç»„ä»¶
@property(nonatomic, strong) AVCaptureSession *captureSession;
@property(nonatomic, strong) AVCaptureDevice *currentDevice;
@property(nonatomic, strong) AVCaptureDeviceInput *deviceInput;
@property(nonatomic, strong) AVCapturePhotoOutput *photoOutput;
@property(nonatomic, strong) AVCaptureVideoPreviewLayer *previewLayer;

// çŠ¶æ€ç®¡ç†
@property(nonatomic, readwrite) CameraState currentState;
@property(nonatomic, readwrite) CameraPosition currentPosition;
@property(nonatomic, readwrite) CameraResolutionMode currentResolutionMode;
@property(nonatomic, readwrite) FlashMode currentFlashMode;
@property(nonatomic, readwrite) CameraAspectRatio currentAspectRatio;
@property(nonatomic, readwrite)
    CameraDeviceOrientation currentDeviceOrientation;
@property(nonatomic, readwrite) BOOL isUltraHighResolutionSupported;
@property(nonatomic, assign) CameraResolutionMode preferredResolutionMode;
// æ ¼å¼ç¼“å­˜å·²è¿ç§»åˆ°CMFormatManager

// æ–¹å‘ç›‘å¬
@property(nonatomic, strong) CMMotionManager *motionManager;

// æ€§èƒ½ä¼˜åŒ– - é˜Ÿåˆ—ç®¡ç†
@property(nonatomic, strong) dispatch_queue_t sessionQueue;

// é•œå¤´ç®¡ç† - å·²è¿ç§»åˆ°CMDeviceManager
// availableLensOptions, currentLensOption, lensDeviceMap é€šè¿‡å±æ€§è®¿é—®å™¨æ¡¥æ¥
// ä½ç½®ç®¡ç†
@property(nonatomic, strong) CMLocationService *locationService; // æ–°ä½ç½®æœåŠ¡
@property(nonatomic, strong) CLLocationManager *locationManager; // ä¿ç•™æ—§å®ç°ä»¥ä¿æŒå…¼å®¹
@property(nonatomic, strong) CLLocation *latestLocation;

// å›¾ç‰‡å¤„ç†
@property(nonatomic, strong) CMImageProcessor *imageProcessor; // å›¾ç‰‡å¤„ç†æ¨¡å—

// æ ¼å¼ç®¡ç†
@property(nonatomic, strong) CMFormatManager *formatManager; // æ ¼å¼ç®¡ç†æ¨¡å—

// è®¾å¤‡ç®¡ç†
@property(nonatomic, strong) CMDeviceManager *deviceManager; // è®¾å¤‡ç®¡ç†æ¨¡å—

// å…ƒæ•°æ®å¢å¼º
@property(nonatomic, strong) CMMetadataEnricher *metadataEnricher; // å…ƒæ•°æ®å¢å¼ºæ¨¡å—

// æ–¹å‘ç®¡ç†
@property(nonatomic, strong) CMOrientationManager *orientationManager; // æ–¹å‘ç®¡ç†æ¨¡å—

- (void)notifyLensUpdate;
- (CGSize)activeFormatDimensions;
- (BOOL)deviceSupportsUltraHighResolution:(AVCaptureDevice *)device;
- (void)primeFormatCachesForDevice:(AVCaptureDevice *)device;
- (AVCaptureDeviceFormat *)standardFormatForDevice:(AVCaptureDevice *)device;
- (AVCaptureDeviceFormat *)ultraHighResolutionFormatForDevice:
    (AVCaptureDevice *)device;
- (AVCaptureDeviceFormat *)findUltraHighResolutionFormatForDevice:
    (AVCaptureDevice *)device;
- (BOOL)applyFormat:(AVCaptureDeviceFormat *)format
           toDevice:(AVCaptureDevice *)device;
- (void)updateUltraHighResolutionSupportForDevice:(AVCaptureDevice *)device;
- (void)applyPreferredResolutionModeLockedWithSupportChanged:
    (BOOL)supportChanged;
- (CMVideoDimensions)maxPhotoDimensionsForFormat:
    (AVCaptureDeviceFormat *)format;
- (void)configureMaxPhotoDimensionsForSettings:
    (AVCapturePhotoSettings *)settings;
- (void)checkUltraHighResolutionSupport;
- (BOOL)performCameraSetup:(NSError **)error;
- (void)setupPreviewLayerWithView:(UIView *)previewView;
- (void)notifyDelegateStateChanged;
- (void)configureLocationServices;
- (void)handleLocationAuthorizationStatus:(CLAuthorizationStatus)status;
- (void)startUpdatingLocationIfPossible;
- (void)stopUpdatingLocationIfNeeded;
- (BOOL)isValidLocation:(CLLocation *)location;
- (AVCaptureVideoOrientation)currentVideoOrientation;
- (AVCapturePhotoSettings *)createPhotoSettings;
- (CLAuthorizationStatus)authorizationStatusForManager:
    (CLLocationManager *)manager;

@end

@implementation CameraManager

#pragma mark - å•ä¾‹æ¨¡å¼

+ (instancetype)sharedManager {
  static CameraManager *sharedInstance = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    sharedInstance = [[CameraManager alloc] initPrivate];
  });
  return sharedInstance;
}

- (instancetype)initPrivate {
  self = [super init];
  if (self) {
    [self commonInit];
  }
  return self;
}

- (void)commonInit {
  // åˆå§‹åŒ–çŠ¶æ€
  _currentState = CameraStateIdle;
  _currentPosition = CameraPositionBack;
  _currentResolutionMode = CameraResolutionModeStandard;
  _preferredResolutionMode = CameraResolutionModeStandard;
  _currentFlashMode = FlashModeAuto;
  _currentAspectRatio = CameraAspectRatio4to3; // é»˜è®¤4:3æ¯”ä¾‹
  _currentDeviceOrientation = CameraDeviceOrientationPortrait; // é»˜è®¤ç«–å±
  // é•œå¤´é€‰é¡¹åˆå§‹åŒ–å·²è¿ç§»åˆ°CMDeviceManager
  // æ ¼å¼ç¼“å­˜åˆå§‹åŒ–å·²è¿ç§»åˆ°CMFormatManager

  // åˆ›å»ºä¸“ç”¨é˜Ÿåˆ— - é¿å…ä¸»çº¿ç¨‹é˜»å¡
  _sessionQueue =
      dispatch_queue_create("com.cameram.session", DISPATCH_QUEUE_SERIAL);

  // åˆå§‹åŒ–æ–¹å‘ç›‘å¬
  _motionManager = [[CMMotionManager alloc] init];

  // æ£€æŸ¥4800ä¸‡åƒç´ æ”¯æŒ
  [self checkUltraHighResolutionSupport];

  // åˆå§‹åŒ–æ–°çš„ä½ç½®æœåŠ¡
  _locationService = [[CMLocationService alloc] init];
  _locationService.delegate = self;

  // åˆå§‹åŒ–å›¾ç‰‡å¤„ç†æ¨¡å—
  _imageProcessor = [[CMImageProcessor alloc] init];

  // åˆå§‹åŒ–æ ¼å¼ç®¡ç†æ¨¡å—
  _formatManager = [[CMFormatManager alloc] init];

  // åˆå§‹åŒ–è®¾å¤‡ç®¡ç†æ¨¡å—
  _deviceManager = [[CMDeviceManager alloc] init];

  // åˆå§‹åŒ–å…ƒæ•°æ®å¢å¼ºæ¨¡å—
  _metadataEnricher = [[CMMetadataEnricher alloc] init];

  // åˆå§‹åŒ–æ–¹å‘ç®¡ç†æ¨¡å—
  _orientationManager = [[CMOrientationManager alloc] init];
  _orientationManager.delegate = self;

  dispatch_async(dispatch_get_main_queue(), ^{
    [self.locationService configure]; // å¯åŠ¨ä½ç½®æœåŠ¡
  });
}

#pragma mark - å…¬å¼€æ–¹æ³•

- (void)setupCameraWithPreviewView:(UIView *)previewView
                        completion:
                            (void (^)(BOOL success,
                                      NSError *_Nullable error))completion {

  // çŠ¶æ€æ£€æŸ¥
  if (self.currentState != CameraStateIdle) {
    NSError *error = [NSError
        errorWithDomain:@"CameraManager"
                   code:1001
               userInfo:@{
                 NSLocalizedDescriptionKey : @"Camera is not in idle state"
               }];
    if (completion)
      completion(NO, error);
    return;
  }

  self.currentState = CameraStateSetup;

  // å¼‚æ­¥æ‰§è¡Œï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
  dispatch_async(self.sessionQueue, ^{
    NSError *setupError = nil;
    BOOL success = [self performCameraSetup:&setupError];

    if (success && previewView) {
      dispatch_async(dispatch_get_main_queue(), ^{
        [self setupPreviewLayerWithView:previewView];
        [self notifyLensUpdate];
        if (completion)
          completion(YES, nil);
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        self.currentState = CameraStateError;
        if (completion)
          completion(NO, setupError);
      });
    }
  });
}

- (void)startSession {
  dispatch_async(self.sessionQueue, ^{
    if (!self.captureSession.isRunning) {
      [self.captureSession startRunning];
      dispatch_async(dispatch_get_main_queue(), ^{
        self.currentState = CameraStateRunning;
        [self notifyDelegateStateChanged];
        [self.locationService startUpdatingLocation]; // å¯åŠ¨ä½ç½®æ›´æ–°
      });
    }
  });
}

- (void)stopSession {
  dispatch_async(self.sessionQueue, ^{
    if (self.captureSession.isRunning) {
      [self.captureSession stopRunning];
      dispatch_async(dispatch_get_main_queue(), ^{
        self.currentState = CameraStateStopped;
        [self notifyDelegateStateChanged];
        [self.locationService stopUpdatingLocation]; // åœæ­¢ä½ç½®æ›´æ–°
      });
    }
  });
}

- (void)capturePhoto {
  if (self.currentState != CameraStateRunning) {
    return;
  }

  self.currentState = CameraStateCapturing;
  [self notifyDelegateStateChanged];

  dispatch_async(self.sessionQueue, ^{
    AVCaptureConnection *photoConnection =
        [self.photoOutput connectionWithMediaType:AVMediaTypeVideo];
    if (photoConnection) {
      if (photoConnection.isVideoOrientationSupported) {
        photoConnection.videoOrientation = [self currentVideoOrientation];
      }
      if (photoConnection.isVideoMirroringSupported) {
        photoConnection.videoMirrored =
            (self.currentPosition == CameraPositionFront);
      }
    }
    AVCapturePhotoSettings *settings = [self createPhotoSettings];
    [self.photoOutput capturePhotoWithSettings:settings delegate:self];
  });

  // åç»­çŠ¶æ€æ›´æ–°åœ¨å›è°ƒä¸­å¤„ç†
}

#pragma mark - ä½ç½®æœåŠ¡

- (void)configureLocationServices {
  if (![CLLocationManager locationServicesEnabled]) {
    NSLog(@"âš ï¸ ä½ç½®æœåŠ¡ä¸å¯ç”¨ï¼Œæ— æ³•å†™å…¥ä½ç½®ä¿¡æ¯åˆ°ç…§ç‰‡ EXIFã€‚");
    return;
  }

  if (!self.locationManager) {
    self.locationManager = [[CLLocationManager alloc] init];
    self.locationManager.delegate = self;
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBest;
    self.locationManager.distanceFilter = 3.0;
    self.locationManager.pausesLocationUpdatesAutomatically = YES;
  }

  CLAuthorizationStatus status;
  status = [self authorizationStatusForManager:self.locationManager];
  [self handleLocationAuthorizationStatus:status];
}

- (void)handleLocationAuthorizationStatus:(CLAuthorizationStatus)status {
  switch (status) {
  case kCLAuthorizationStatusNotDetermined:
    [self.locationManager requestWhenInUseAuthorization];
    break;
#if __IPHONE_OS_VERSION_MIN_REQUIRED < 140000
  case kCLAuthorizationStatusAuthorized:
#endif
  case kCLAuthorizationStatusAuthorizedAlways:
  case kCLAuthorizationStatusAuthorizedWhenInUse:
    [self startUpdatingLocationIfPossible]; // æ—§å®ç°
    [self.locationService startUpdatingLocation]; // æ–°å®ç°(å¹¶è¡Œè¿è¡Œ)
    break;
  case kCLAuthorizationStatusDenied:
  case kCLAuthorizationStatusRestricted:
    [self stopUpdatingLocationIfNeeded]; // æ—§å®ç°
    [self.locationService stopUpdatingLocation]; // æ–°å®ç°(å¹¶è¡Œè¿è¡Œ)
    self.latestLocation = nil;
    break;
  default:
    break;
  }
}

- (void)startUpdatingLocationIfPossible {
  if (!self.locationManager || ![CLLocationManager locationServicesEnabled]) {
    return;
  }

  CLAuthorizationStatus status;
  status = [self authorizationStatusForManager:self.locationManager];

  if (status == kCLAuthorizationStatusAuthorizedWhenInUse ||
      status == kCLAuthorizationStatusAuthorizedAlways
#if __IPHONE_OS_VERSION_MIN_REQUIRED < 140000
      || status == kCLAuthorizationStatusAuthorized
#endif
  ) {
    [self.locationManager startUpdatingLocation];
  }
}

- (void)stopUpdatingLocationIfNeeded {
  if (!self.locationManager) {
    return;
  }
  [self.locationManager stopUpdatingLocation];
}

- (CLAuthorizationStatus)authorizationStatusForManager:
    (CLLocationManager *)manager {
  if (@available(iOS 14.0, *)) {
    return manager.authorizationStatus;
  }
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  return [CLLocationManager authorizationStatus];
#pragma clang diagnostic pop
}

- (void)locationManagerDidChangeAuthorization:(CLLocationManager *)manager {
  CLAuthorizationStatus status =
      [self authorizationStatusForManager:manager];
  [self handleLocationAuthorizationStatus:status];
}

#if __IPHONE_OS_VERSION_MIN_REQUIRED < 140000
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"
- (void)locationManager:(CLLocationManager *)manager
    didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
  [self handleLocationAuthorizationStatus:status];
}
#pragma clang diagnostic pop
#endif

- (void)locationManager:(CLLocationManager *)manager
     didUpdateLocations:(NSArray<CLLocation *> *)locations {
  CLLocation *latest = locations.lastObject;
  if ([self isValidLocation:latest]) {
    self.latestLocation = latest;
  }
}

- (void)locationManager:(CLLocationManager *)manager
       didFailWithError:(NSError *)error {
  NSLog(@"âš ï¸ å®šä½å¤±è´¥: %@", error.localizedDescription);
}

#pragma mark - CMLocationServiceDelegate

- (void)locationService:(CMLocationService *)service
     didUpdateLocation:(CLLocation *)location {
  // åŒæ­¥åˆ°æ—§å±æ€§,ä¿æŒå‘åå…¼å®¹
  self.latestLocation = location;
  NSLog(@"âœ… [NEW] Location updated via CMLocationService: %@", location);
}

- (void)locationService:(CMLocationService *)service
       didFailWithError:(NSError *)error {
  NSLog(@"âš ï¸ [NEW] Location failed via CMLocationService: %@", error.localizedDescription);
}

- (void)locationService:(CMLocationService *)service
    didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
  NSLog(@"â„¹ï¸ [NEW] Location authorization changed via CMLocationService: %ld", (long)status);
}

- (void)switchCamera {
  dispatch_async(self.sessionQueue, ^{
    // åˆ‡æ¢æ‘„åƒå¤´é€»è¾‘
    CameraPosition newPosition = (self.currentPosition == CameraPositionBack)
                                     ? CameraPositionFront
                                     : CameraPositionBack;

    [self.captureSession beginConfiguration];

    // ç§»é™¤å½“å‰è¾“å…¥
    if (self.deviceInput) {
      [self.captureSession removeInput:self.deviceInput];
    }

    NSArray<AVCaptureDevice *> *devices =
        [self discoverDevicesForPosition:newPosition];
    [self rebuildLensOptionsForPosition:newPosition
                                devices:devices
                           shouldNotify:NO];

    AVCaptureDevice *newDevice =
        [self deviceForLensOption:self.currentLensOption devices:devices];
    if (!newDevice) {
      newDevice = devices.firstObject ?: [self cameraWithPosition:newPosition];
    }

    NSError *error = nil;
    AVCaptureDeviceInput *newInput =
        newDevice ? [AVCaptureDeviceInput deviceInputWithDevice:newDevice
                                                          error:&error]
                  : nil;
    if (newInput && [self.captureSession canAddInput:newInput]) {
      [self.captureSession addInput:newInput];
      self.deviceInput = newInput;
      self.currentDevice = newDevice;
      self.currentPosition = newPosition;
      [self primeFormatCachesForDevice:self.currentDevice];
    } else if (error) {
      NSLog(@"âš ï¸ åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥: %@", error.localizedDescription);
      if (self.deviceInput) {
        [self.captureSession addInput:self.deviceInput];
      }
    }

    [self.captureSession commitConfiguration];

    [self updateUltraHighResolutionSupportForDevice:self.currentDevice];

    [self notifyLensUpdate];
  });
}

- (void)switchResolutionMode:(CameraResolutionMode)mode {
  dispatch_async(self.sessionQueue, ^{
    self.preferredResolutionMode = mode;
    [self applyPreferredResolutionModeLockedWithSupportChanged:NO];
  });
}

- (void)switchFlashMode:(FlashMode)mode {
  // ç°ä»£é—ªå…‰ç¯æ§åˆ¶é€šè¿‡PhotoSettingså®ç°ï¼Œè¿™é‡Œåªä¿å­˜çŠ¶æ€
  self.currentFlashMode = mode;

  dispatch_async(dispatch_get_main_queue(), ^{
    if ([self.delegate respondsToSelector:@selector(cameraManager:
                                               didChangeFlashMode:)]) {
      [self.delegate cameraManager:self didChangeFlashMode:mode];
    }
  });
}

- (void)switchAspectRatio:(CameraAspectRatio)ratio {
  self.currentAspectRatio = ratio;

  dispatch_async(dispatch_get_main_queue(), ^{
    if ([self.delegate respondsToSelector:@selector(cameraManager:
                                              didChangeAspectRatio:)]) {
      [self.delegate cameraManager:self didChangeAspectRatio:ratio];
    }
  });
}

- (void)switchToLensOption:(CMCameraLensOption *)lensOption {
  if (!lensOption) {
    return;
  }

  dispatch_async(self.sessionQueue, ^{
    CMCameraLensOption *targetOption = nil;
    for (CMCameraLensOption *option in self.availableLensOptions) {
      if ([option.identifier isEqualToString:lensOption.identifier]) {
        targetOption = option;
        break;
      }
    }
    if (!targetOption) {
      return;
    }

    // é€šè¿‡CMDeviceManagerè·å–è®¾å¤‡
    AVCaptureDevice *targetDevice =
        [self.deviceManager deviceByUniqueID:targetOption.deviceUniqueID];
    if (!targetDevice) {
      NSArray<AVCaptureDevice *> *devices =
          [self discoverDevicesForPosition:self.currentPosition];
      [self rebuildLensOptionsForPosition:self.currentPosition
                                  devices:devices
                             shouldNotify:NO];
      targetOption = nil;
      for (CMCameraLensOption *option in self.availableLensOptions) {
        if ([option.identifier isEqualToString:lensOption.identifier]) {
          targetOption = option;
          break;
        }
      }
      if (!targetOption) {
        return;
      }
      targetDevice = [self.deviceManager deviceByUniqueID:targetOption.deviceUniqueID];
    }

    if (!targetDevice ||
        [targetDevice.uniqueID isEqualToString:self.currentDevice.uniqueID]) {
      self.currentLensOption = targetOption;
      [self notifyLensUpdate];
      return;
    }

    NSError *inputError = nil;
    AVCaptureDeviceInput *newInput =
        [AVCaptureDeviceInput deviceInputWithDevice:targetDevice
                                              error:&inputError];
    if (!newInput) {
      NSLog(@"âš ï¸ åˆ‡æ¢é•œå¤´å¤±è´¥: %@", inputError.localizedDescription);
      return;
    }

    [self.captureSession beginConfiguration];
    AVCaptureDeviceInput *previousInput = self.deviceInput;
    if (previousInput) {
      [self.captureSession removeInput:previousInput];
    }

    BOOL didAddInput = NO;
    if ([self.captureSession canAddInput:newInput]) {
      [self.captureSession addInput:newInput];
      self.deviceInput = newInput;
      self.currentDevice = targetDevice;
      self.currentLensOption = targetOption;
      [self primeFormatCachesForDevice:self.currentDevice];
      didAddInput = YES;
    } else if (previousInput) {
      [self.captureSession addInput:previousInput];
    }
    [self.captureSession commitConfiguration];

    if (!didAddInput) {
      NSLog(@"âš ï¸ åˆ‡æ¢é•œå¤´å¤±è´¥: æ— æ³•æ·»åŠ è¾“å…¥");
      return;
    }

    [self updateUltraHighResolutionSupportForDevice:self.currentDevice];

    [self notifyLensUpdate];
  });
}

#pragma mark - è®¾å¤‡æ–¹å‘ç›¸å…³

- (void)startDeviceOrientationMonitoring {
  // å§”æ‰˜ç»™CMOrientationManager
  [self.orientationManager startMonitoring];
}

- (void)stopDeviceOrientationMonitoring {
  // å§”æ‰˜ç»™CMOrientationManager
  [self.orientationManager stopMonitoring];
}

#pragma mark - CMOrientationManagerDelegate

- (void)orientationManager:(CMOrientationManager *)manager
    didChangeDeviceOrientation:(CameraDeviceOrientation)orientation {
  // åŒæ­¥åˆ°æœ¬åœ°å±æ€§
  self.currentDeviceOrientation = orientation;

  // ç«‹å³æ›´æ–°é¢„è§ˆå±‚æ–¹å‘
  [self updatePreviewLayerOrientation];

  // é€šçŸ¥ä»£ç†
  dispatch_async(dispatch_get_main_queue(), ^{
    if ([self.delegate respondsToSelector:@selector(cameraManager:
                                              didChangeDeviceOrientation:)]) {
      [self.delegate cameraManager:self
          didChangeDeviceOrientation:orientation];
    }
  });
}

// æ›´æ–°é¢„è§ˆå±‚æ–¹å‘
- (void)updatePreviewLayerOrientation {
  if (!self.previewLayer || !self.previewLayer.connection) {
    return;
  }

  AVCaptureVideoOrientation videoOrientation = [self currentVideoOrientation];

  dispatch_async(dispatch_get_main_queue(), ^{
    if (self.previewLayer.connection.isVideoOrientationSupported) {
      // ä½¿ç”¨CATransactionç¡®ä¿åŒæ­¥æ›´æ–°
      [CATransaction begin];
      [CATransaction setDisableActions:YES]; // ç¦ç”¨éšå¼åŠ¨ç”»
      self.previewLayer.connection.videoOrientation = videoOrientation;
      [CATransaction commit];

      NSLog(@"ğŸ”„ é¢„è§ˆå±‚æ–¹å‘å·²æ›´æ–°: %ld, frame: %@", (long)videoOrientation,
            NSStringFromCGRect(self.previewLayer.frame));
    }
  });
}

// è·å–å½“å‰è§†é¢‘æ–¹å‘ - å§”æ‰˜ç»™CMOrientationManager
- (AVCaptureVideoOrientation)currentVideoOrientation {
  return [self.orientationManager currentVideoOrientation];
}

#pragma mark - æ¯”ä¾‹ç›¸å…³å·¥å…·æ–¹æ³•

- (CGRect)cropRectForAspectRatio:(CameraAspectRatio)ratio
                     inImageSize:(CGSize)imageSize {
  // å§”æ‰˜ç»™CMImageProcessor
  return [self.imageProcessor cropRectForAspectRatio:ratio
                                         inImageSize:imageSize
                                     withOrientation:self.currentDeviceOrientation];
}

- (UIImage *)cropImage:(UIImage *)image toAspectRatio:(CameraAspectRatio)ratio {
  // ä½¿ç”¨CMImageProcessorå¤„ç†å›¾ç‰‡è£å‰ª
  return [self.imageProcessor cropImage:image
                         toAspectRatio:ratio
                       withOrientation:self.currentDeviceOrientation];
}

// æ ‡å‡†åŒ–å›¾åƒæ–¹å‘ - å§”æ‰˜ç»™CMImageProcessor
- (UIImage *)normalizeImageOrientation:(UIImage *)image {
  return [self.imageProcessor normalizeImageOrientation:image];
}

- (CGFloat)aspectRatioValueForRatio:(CameraAspectRatio)ratio {
  return [self aspectRatioValueForRatio:ratio
                          inOrientation:self.currentDeviceOrientation];
}

- (CGFloat)aspectRatioValueForRatio:(CameraAspectRatio)ratio
                      inOrientation:(CameraDeviceOrientation)orientation {
  BOOL isPortrait = (orientation == CameraDeviceOrientationPortrait);

  switch (ratio) {
  case CameraAspectRatio4to3:
    // ç«–å±: 3:4 (0.75), æ¨ªå±: 4:3 (1.33)
    return isPortrait ? (3.0f / 4.0f) : (4.0f / 3.0f);
  case CameraAspectRatio1to1:
    // æ­£æ–¹å½¢åœ¨ä»»ä½•æ–¹å‘éƒ½æ˜¯1:1
    return 1.0f;
  case CameraAspectRatioXpan:
    // ç«–å±: 24:65 (0.37), æ¨ªå±: 65:24 (2.7)
    return isPortrait ? (24.0f / 65.0f) : (65.0f / 24.0f);
  }
  return 1.0f;
}

- (CGSize)activeFormatDimensions {
  AVCaptureDevice *device = self.currentDevice ?: self.deviceInput.device;
  if (!device) {
    return CGSizeZero;
  }

  CMFormatDescriptionRef description = device.activeFormat.formatDescription;
  if (!description) {
    return CGSizeZero;
  }

  CMVideoDimensions dimensions =
      CMVideoFormatDescriptionGetDimensions(description);
  if (dimensions.width <= 0 || dimensions.height <= 0) {
    return CGSizeZero;
  }

  return CGSizeMake(dimensions.width, dimensions.height);
}

- (CGRect)previewRectForAspectRatio:(CameraAspectRatio)ratio
                         inViewSize:(CGSize)viewSize {
  const CGFloat viewWidth = viewSize.width;
  const CGFloat viewHeight = viewSize.height;

  if (viewWidth <= 0.0f || viewHeight <= 0.0f) {
    return CGRectZero;
  }

  const CGFloat targetAspect =
      [self aspectRatioValueForRatio:ratio
                       inOrientation:self.currentDeviceOrientation];
  const CGFloat viewAspect = viewWidth / viewHeight;

  CGRect rect = CGRectMake(0.0f, 0.0f, viewWidth, viewHeight);

  if (fabs(viewAspect - targetAspect) < 0.0001f) {
    return CGRectIntegral(rect);
  }

  if (viewAspect > targetAspect) {
    const CGFloat targetWidth = viewHeight * targetAspect;
    const CGFloat xOffset = (viewWidth - targetWidth) / 2.0f;
    rect = CGRectMake(xOffset, 0.0f, targetWidth, viewHeight);
  } else {
    const CGFloat targetHeight = viewWidth / targetAspect;
    const CGFloat yOffset = (viewHeight - targetHeight) / 2.0f;
    rect = CGRectMake(0.0f, yOffset, viewWidth, targetHeight);
  }

  return CGRectIntegral(rect);
}

- (CGRect)activeFormatPreviewRectInViewSize:(CGSize)viewSize {
  const CGFloat viewWidth = viewSize.width;
  const CGFloat viewHeight = viewSize.height;

  if (viewWidth <= 0.0f || viewHeight <= 0.0f) {
    return CGRectZero;
  }

  CGSize activeDimensions = [self activeFormatDimensions];
  if (activeDimensions.width <= 0.0f || activeDimensions.height <= 0.0f) {
    return CGRectIntegral(CGRectMake(0.0f, 0.0f, viewWidth, viewHeight));
  }

  CGRect boundingRect = CGRectMake(0.0f, 0.0f, viewWidth, viewHeight);
  CGRect videoRect =
      AVMakeRectWithAspectRatioInsideRect(activeDimensions, boundingRect);
  return CGRectIntegral(videoRect);
}

- (void)focusAtPoint:(CGPoint)point {
  dispatch_async(self.sessionQueue, ^{
    if (self.currentDevice &&
        [self.currentDevice isFocusModeSupported:AVCaptureFocusModeAutoFocus]) {
      NSError *error = nil;

      if ([self.currentDevice lockForConfiguration:&error]) {
        // è®¾ç½®å¯¹ç„¦ç‚¹
        if ([self.currentDevice isFocusPointOfInterestSupported]) {
          self.currentDevice.focusPointOfInterest = point;
          self.currentDevice.focusMode = AVCaptureFocusModeAutoFocus;
        }

        // è®¾ç½®æ›å…‰ç‚¹
        if ([self.currentDevice isExposurePointOfInterestSupported]) {
          self.currentDevice.exposurePointOfInterest = point;
          self.currentDevice.exposureMode = AVCaptureExposureModeAutoExpose;
        }

        [self.currentDevice unlockForConfiguration];

        NSLog(@"å¯¹ç„¦è®¾ç½®æˆåŠŸ: (%.2f, %.2f)", point.x, point.y);
      } else {
        NSLog(@"å¯¹ç„¦è®¾ç½®å¤±è´¥: %@", error.localizedDescription);
      }
    }
  });
}

- (void)setExposureCompensation:(float)value {
  dispatch_async(self.sessionQueue, ^{
    if (self.currentDevice) {
      NSError *error = nil;

      if ([self.currentDevice lockForConfiguration:&error]) {
        // é™åˆ¶æ›å…‰è¡¥å¿èŒƒå›´
        float minEV = self.currentDevice.minExposureTargetBias;
        float maxEV = self.currentDevice.maxExposureTargetBias;
        float clampedValue = MAX(minEV, MIN(maxEV, value));

        [self.currentDevice
            setExposureTargetBias:clampedValue
                completionHandler:^(CMTime syncTime) {
                  NSLog(@"æ›å…‰è¡¥å¿è®¾ç½®æˆåŠŸ: %.1f", clampedValue);
                }];

        [self.currentDevice unlockForConfiguration];
      } else {
        NSLog(@"æ›å…‰è¡¥å¿è®¾ç½®å¤±è´¥: %@", error.localizedDescription);
      }
    }
  });
}

#pragma mark - ç§æœ‰æ–¹æ³•

#pragma mark é•œå¤´ç®¡ç†

- (NSArray<AVCaptureDevice *> *)discoverDevicesForPosition:
    (CameraPosition)position {
  // å§”æ‰˜ç»™CMDeviceManager
  return [self.deviceManager discoverDevicesForPosition:position];
}

// canonicalZoomForDevice å’Œ titleForZoomFactor æ–¹æ³•å·²è¿ç§»åˆ° CMDeviceManager

- (void)rebuildLensOptionsForPosition:(CameraPosition)position
                              devices:(NSArray<AVCaptureDevice *> *)devices
                         shouldNotify:(BOOL)notify {
  // å§”æ‰˜ç»™CMDeviceManager
  [self.deviceManager rebuildLensOptionsForPosition:position
                                            devices:devices
                                       shouldNotify:notify];
  if (notify) {
    [self notifyLensUpdate];
  }
}

- (AVCaptureDevice *)deviceForLensOption:(CMCameraLensOption *)lensOption
                                 devices:(NSArray<AVCaptureDevice *> *)devices {
  // å§”æ‰˜ç»™CMDeviceManager
  return [self.deviceManager deviceForLensOption:lensOption devices:devices];
}

- (void)notifyLensUpdate {
  // ä½¿ç”¨CMDeviceManagerçš„å¿«ç…§æ–¹æ³•
  NSArray<CMCameraLensOption *> *lensSnapshot = [self.deviceManager lensOptionsSnapshot];
  CMCameraLensOption *currentSnapshot = [self.deviceManager currentLensOptionSnapshot];

  if (!lensSnapshot) {
    lensSnapshot = @[];
  }
  if (!currentSnapshot && lensSnapshot.count > 0) {
    currentSnapshot = [lensSnapshot.firstObject copy];
  }

  dispatch_async(dispatch_get_main_queue(), ^{
    if ([self.delegate respondsToSelector:@selector
                       (cameraManager:didUpdateAvailableLenses:currentLens:)]) {
      [self.delegate cameraManager:self
          didUpdateAvailableLenses:lensSnapshot
                       currentLens:currentSnapshot];
    }
  });
}

- (BOOL)performCameraSetup:(NSError **)error {
  // åˆ›å»ºcapture session
  self.captureSession = [[AVCaptureSession alloc] init];

  // è®¾ç½®session preset - æ€§èƒ½ä¼˜åŒ–
  if ([self.captureSession canSetSessionPreset:AVCaptureSessionPresetPhoto]) {
    [self.captureSession setSessionPreset:AVCaptureSessionPresetPhoto];
  }

  NSArray<AVCaptureDevice *> *availableDevices =
      [self discoverDevicesForPosition:self.currentPosition];
  [self rebuildLensOptionsForPosition:self.currentPosition
                              devices:availableDevices
                         shouldNotify:NO];

  self.currentDevice = [self deviceForLensOption:self.currentLensOption
                                         devices:availableDevices];
  if (!self.currentDevice) {
    self.currentDevice = availableDevices.firstObject
                             ?: [self cameraWithPosition:self.currentPosition];
  }
  if (!self.currentDevice) {
    if (error) {
      *error = [NSError
          errorWithDomain:@"CameraManager"
                     code:1002
                 userInfo:@{
                   NSLocalizedDescriptionKey : @"No camera device available"
                 }];
    }
    return NO;
  }

  // åˆ›å»ºè®¾å¤‡è¾“å…¥
  NSError *inputError = nil;
  self.deviceInput =
      [AVCaptureDeviceInput deviceInputWithDevice:self.currentDevice
                                            error:&inputError];
  if (!self.deviceInput) {
    if (error)
      *error = inputError;
    return NO;
  }

  // æ·»åŠ è¾“å…¥åˆ°session
  if ([self.captureSession canAddInput:self.deviceInput]) {
    [self.captureSession addInput:self.deviceInput];
  } else {
    if (error) {
      *error = [NSError
          errorWithDomain:@"CameraManager"
                     code:1003
                 userInfo:@{
                   NSLocalizedDescriptionKey : @"Cannot add camera input"
                 }];
    }
    return NO;
  }

  [self primeFormatCachesForDevice:self.currentDevice];

  // åˆ›å»ºç…§ç‰‡è¾“å‡º
  self.photoOutput = [[AVCapturePhotoOutput alloc] init];
  if ([self.captureSession canAddOutput:self.photoOutput]) {
    [self.captureSession addOutput:self.photoOutput];
    self.photoOutput.highResolutionCaptureEnabled = YES;
    [self
        configurePhotoOutputForResolutionMode:self.currentResolutionMode
                                   withFormat:self.currentDevice.activeFormat];
  } else {
    if (error) {
      *error = [NSError
          errorWithDomain:@"CameraManager"
                     code:1004
                 userInfo:@{
                   NSLocalizedDescriptionKey : @"Cannot add photo output"
                 }];
    }
    return NO;
  }

  [self updateUltraHighResolutionSupportForDevice:self.currentDevice];

  return YES;
}

- (void)setupPreviewLayerWithView:(UIView *)view {
  self.previewLayer =
      [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];
  self.previewLayer.frame = view.bounds;
  self.previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;
  [view.layer insertSublayer:self.previewLayer atIndex:0];

  // è®¾ç½®åˆå§‹æ–¹å‘
  [self updatePreviewLayerOrientation];

  NSLog(@"ğŸ“± é¢„è§ˆå±‚åˆå§‹åŒ–å®Œæˆï¼Œframe: %@",
        NSStringFromCGRect(self.previewLayer.frame));
}

- (AVCaptureDevice *)cameraWithPosition:(CameraPosition)position {
  AVCaptureDevicePosition avPosition = (position == CameraPositionBack)
                                           ? AVCaptureDevicePositionBack
                                           : AVCaptureDevicePositionFront;

  // ä¼˜å…ˆä½¿ç”¨å¤šæ‘„åƒå¤´ç³»ç»Ÿ
  AVCaptureDeviceDiscoverySession *discoverySession =
      [AVCaptureDeviceDiscoverySession
          discoverySessionWithDeviceTypes:@[
            AVCaptureDeviceTypeBuiltInTripleCamera,
            AVCaptureDeviceTypeBuiltInDualWideCamera,
            AVCaptureDeviceTypeBuiltInWideAngleCamera
          ]
                                mediaType:AVMediaTypeVideo
                                 position:avPosition];

  return discoverySession.devices.firstObject;
}

- (void)checkUltraHighResolutionSupport {
  AVCaptureDevice *backCamera = [self cameraWithPosition:CameraPositionBack];
  [self primeFormatCachesForDevice:backCamera];
  BOOL supported = [self deviceSupportsUltraHighResolution:backCamera];
  self.isUltraHighResolutionSupported = supported;
  if (!supported) {
    self.preferredResolutionMode = CameraResolutionModeStandard;
    self.currentResolutionMode = CameraResolutionModeStandard;
  }
}

- (void)configurePhotoOutputForResolutionMode:(CameraResolutionMode)mode
                                   withFormat:(AVCaptureDeviceFormat *)format {
  if (!self.photoOutput) {
    return;
  }

  if (@available(iOS 17.0, *)) {
    CMVideoDimensions dimensions = [self maxPhotoDimensionsForFormat:format];
    if (dimensions.width > 0 && dimensions.height > 0) {
      self.photoOutput.maxPhotoDimensions = dimensions;
    }
  }

  if (@available(iOS 16.0, *)) {
    if (mode == CameraResolutionModeUltraHigh &&
        self.isUltraHighResolutionSupported) {
      self.photoOutput.maxPhotoQualityPrioritization =
          AVCapturePhotoQualityPrioritizationQuality;
    } else {
      self.photoOutput.maxPhotoQualityPrioritization =
          AVCapturePhotoQualityPrioritizationBalanced;
    }
  }

  if (@available(iOS 11.0, *)) {
    self.photoOutput.highResolutionCaptureEnabled = YES;
  }
}

#pragma mark - åˆ†è¾¨ç‡ç®¡ç†

- (BOOL)deviceSupportsUltraHighResolution:(AVCaptureDevice *)device {
  // å§”æ‰˜ç»™CMFormatManager
  return [self.formatManager deviceSupportsUltraHighResolution:device];
}

- (void)primeFormatCachesForDevice:(AVCaptureDevice *)device {
  // å§”æ‰˜ç»™CMFormatManager
  [self.formatManager primeFormatCachesForDevice:device];
}

- (CMVideoDimensions)maxPhotoDimensionsForFormat:(AVCaptureDeviceFormat *)format {
  // å§”æ‰˜ç»™CMFormatManager
  return [self.formatManager maxPhotoDimensionsForFormat:format];
}

- (void)configureMaxPhotoDimensionsForSettings:(AVCapturePhotoSettings *)settings {
  // å§”æ‰˜ç»™CMFormatManager
  [self.formatManager configureMaxPhotoDimensionsForSettings:settings
                                                 photoOutput:self.photoOutput
                                                currentDevice:self.currentDevice];
}

// æ ¼å¼ç®¡ç†æ–¹æ³•å·²è¿ç§»åˆ°CMFormatManager

- (AVCaptureDeviceFormat *)standardFormatForDevice:(AVCaptureDevice *)device {
  return [self.formatManager standardFormatForDevice:device];
}

- (AVCaptureDeviceFormat *)ultraHighResolutionFormatForDevice:(AVCaptureDevice *)device {
  return [self.formatManager ultraHighResolutionFormatForDevice:device];
}

- (AVCaptureDeviceFormat *)findUltraHighResolutionFormatForDevice:(AVCaptureDevice *)device {
  return [self.formatManager findUltraHighResolutionFormatForDevice:device];
}

- (BOOL)applyFormat:(AVCaptureDeviceFormat *)format toDevice:(AVCaptureDevice *)device {
  return [self.formatManager applyFormat:format toDevice:device];
}

- (void)updateUltraHighResolutionSupportForDevice:(AVCaptureDevice *)device {
  BOOL previousSupport = self.isUltraHighResolutionSupported;
  [self primeFormatCachesForDevice:device];
  BOOL currentSupport = [self deviceSupportsUltraHighResolution:device];
  self.isUltraHighResolutionSupported = currentSupport;

  BOOL supportChanged = (previousSupport != currentSupport);
  [self applyPreferredResolutionModeLockedWithSupportChanged:supportChanged];
}

- (void)applyPreferredResolutionModeLockedWithSupportChanged:
    (BOOL)supportChanged {
  CameraResolutionMode desiredMode = self.preferredResolutionMode;
  CameraResolutionMode resolvedMode = desiredMode;
  AVCaptureDevice *device = self.currentDevice;

  BOOL requestedUltra = (desiredMode == CameraResolutionModeUltraHigh);
  BOOL fallbackDueToSupport = NO;

  if (requestedUltra && !self.isUltraHighResolutionSupported) {
    fallbackDueToSupport = YES;
    resolvedMode = CameraResolutionModeStandard;
  }

  if (!self.captureSession || !self.photoOutput || !device) {
    self.currentResolutionMode = resolvedMode;
    return;
  }

  [self primeFormatCachesForDevice:device];

  AVCaptureDeviceFormat *targetFormat = nil;
  if (resolvedMode == CameraResolutionModeUltraHigh) {
    targetFormat = [self ultraHighResolutionFormatForDevice:device];
    if (!targetFormat) {
      fallbackDueToSupport = YES;
      resolvedMode = CameraResolutionModeStandard;
    }
  }

  if (resolvedMode == CameraResolutionModeStandard) {
    targetFormat = [self standardFormatForDevice:device];
  }

  if (!targetFormat) {
    targetFormat = device.activeFormat;
  }

  BOOL didChangeMode = (self.currentResolutionMode != resolvedMode);
  BOOL alreadyUsingTargetFormat = (device.activeFormat == targetFormat);

  if (!didChangeMode && alreadyUsingTargetFormat) {
    self.currentResolutionMode = resolvedMode;
    if (supportChanged) {
      dispatch_async(dispatch_get_main_queue(), ^{
        if ([self.delegate respondsToSelector:@selector(cameraManager:
                                                  didChangeResolutionMode:)]) {
          [self.delegate cameraManager:self
               didChangeResolutionMode:self.currentResolutionMode];
        }
      });
    }
    return;
  }

  [self.captureSession beginConfiguration];
  BOOL formatChanged = [self applyFormat:targetFormat toDevice:device];
  AVCaptureDeviceFormat *appliedFormat =
      formatChanged ? targetFormat : device.activeFormat;
  BOOL formatApplied = (appliedFormat == targetFormat);
  if (resolvedMode == CameraResolutionModeUltraHigh && !formatApplied) {
    fallbackDueToSupport = YES;
    resolvedMode = CameraResolutionModeStandard;
  }
  [self configurePhotoOutputForResolutionMode:resolvedMode
                                   withFormat:appliedFormat];
  [self.captureSession commitConfiguration];

  BOOL finalModeChanged = (self.currentResolutionMode != resolvedMode);
  self.currentResolutionMode = resolvedMode;

  // æ ¼å¼ç¼“å­˜æ›´æ–°å·²ç”±CMFormatManagerå†…éƒ¨å¤„ç†

  if (resolvedMode == CameraResolutionModeUltraHigh) {
    NSLog(@"âœ… å·²å¯ç”¨4800ä¸‡åƒç´ æ¨¡å¼");
  } else if (requestedUltra &&
             (finalModeChanged || formatChanged || fallbackDueToSupport)) {
    NSLog(@"âš ï¸ å½“å‰é•œå¤´ä¸æ”¯æŒ4800ä¸‡åƒç´ ï¼Œå›é€€åˆ°æ ‡å‡†åˆ†è¾¨ç‡");
  }

  if (supportChanged || finalModeChanged || formatChanged) {
    dispatch_async(dispatch_get_main_queue(), ^{
      if ([self.delegate respondsToSelector:@selector(cameraManager:
                                                didChangeResolutionMode:)]) {
        [self.delegate cameraManager:self
             didChangeResolutionMode:self.currentResolutionMode];
      }
    });
  }
}

- (AVCapturePhotoSettings *)createPhotoSettings {
  AVCapturePhotoSettings *settings = [AVCapturePhotoSettings photoSettings];

  // 4800ä¸‡åƒç´ æ¨¡å¼é…ç½®
  if (self.currentResolutionMode == CameraResolutionModeUltraHigh &&
      self.isUltraHighResolutionSupported) {
    if (@available(iOS 16.0, *)) {
      settings.photoQualityPrioritization =
          AVCapturePhotoQualityPrioritizationQuality;
    }
    if (@available(iOS 11.0, *)) {
      settings.highResolutionPhotoEnabled = YES;
    }
  } else {
    if (@available(iOS 16.0, *)) {
      settings.photoQualityPrioritization =
          AVCapturePhotoQualityPrioritizationBalanced;
    }
    if (@available(iOS 11.0, *)) {
      settings.highResolutionPhotoEnabled = NO;
    }
  }

  // åº”ç”¨é—ªå…‰ç¯è®¾ç½®
  if (self.currentDevice && [self.currentDevice hasFlash]) {
    switch (self.currentFlashMode) {
    case FlashModeAuto:
      settings.flashMode = AVCaptureFlashModeAuto;
      break;
    case FlashModeOn:
      settings.flashMode = AVCaptureFlashModeOn;
      break;
    case FlashModeOff:
      settings.flashMode = AVCaptureFlashModeOff;
      break;
    }
  }

  // å¯ç”¨é«˜è´¨é‡æ‹æ‘„
  if ([self.photoOutput.availablePhotoCodecTypes
          containsObject:AVVideoCodecTypeHEVC]) {
    settings = [AVCapturePhotoSettings
        photoSettingsWithFormat:@{AVVideoCodecKey : AVVideoCodecTypeHEVC}];

    // é‡æ–°åº”ç”¨é—ªå…‰ç¯è®¾ç½®
    if (self.currentDevice && [self.currentDevice hasFlash]) {
      switch (self.currentFlashMode) {
      case FlashModeAuto:
        settings.flashMode = AVCaptureFlashModeAuto;
        break;
      case FlashModeOn:
        settings.flashMode = AVCaptureFlashModeOn;
        break;
      case FlashModeOff:
        settings.flashMode = AVCaptureFlashModeOff;
        break;
      }
    }

    // é‡æ–°åº”ç”¨åˆ†è¾¨ç‡è®¾ç½®
    if (self.currentResolutionMode == CameraResolutionModeUltraHigh &&
        self.isUltraHighResolutionSupported) {
      if (@available(iOS 16.0, *)) {
        settings.photoQualityPrioritization =
            AVCapturePhotoQualityPrioritizationQuality;
      }
      if (@available(iOS 11.0, *)) {
        settings.highResolutionPhotoEnabled = YES;
      }
    } else {
      if (@available(iOS 16.0, *)) {
        settings.photoQualityPrioritization =
            AVCapturePhotoQualityPrioritizationBalanced;
      }
      if (@available(iOS 11.0, *)) {
        settings.highResolutionPhotoEnabled = NO;
      }
    }
  }

  [self configureMaxPhotoDimensionsForSettings:settings];

  return settings;
}

#pragma mark - AVCapturePhotoCaptureDelegate

- (void)captureOutput:(AVCapturePhotoOutput *)output
    didFinishProcessingPhoto:(AVCapturePhoto *)photo
                       error:(NSError *)error {

  dispatch_async(dispatch_get_main_queue(), ^{
    self.currentState = CameraStateRunning;
    [self notifyDelegateStateChanged];

    if (error) {
      if ([self.delegate respondsToSelector:@selector(cameraManager:
                                                   didFailWithError:)]) {
        [self.delegate cameraManager:self didFailWithError:error];
      }
      return;
    }

    NSData *imageData = photo.fileDataRepresentation;
    if (imageData) {
      UIImage *image = [UIImage imageWithData:imageData];
      NSDictionary *enrichedMetadata =
          [self enrichedMetadataFromPhoto:photo originalMetadata:photo.metadata];

      if ([self.delegate respondsToSelector:@selector
                         (cameraManager:didCapturePhoto:withMetadata:)]) {
        [self.delegate cameraManager:self
                     didCapturePhoto:image
                        withMetadata:enrichedMetadata];
      }
    }
  });
}

#pragma mark - ç›¸å†Œä¿å­˜

- (void)saveImageToPhotosLibrary:(UIImage *)image
                        metadata:(NSDictionary *)metadata
                      completion:
                          (void (^)(BOOL success,
                                    NSError *_Nullable error))completion {
  // ä½¿ç”¨CMImageProcessorä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œ
  [self.imageProcessor saveImageToPhotosLibrary:image
                                       metadata:metadata
                                     completion:completion];
}

#pragma mark - å…ƒæ•°æ®è¾…åŠ©

// å…ƒæ•°æ®è¾…åŠ©æ–¹æ³•å·²è¿ç§»åˆ°CMMetadataEnricher

- (NSDictionary *)enrichedMetadataFromPhoto:(AVCapturePhoto *)photo
                           originalMetadata:(NSDictionary *)metadata {
  // å§”æ‰˜ç»™CMMetadataEnricher
  return [self.metadataEnricher enrichMetadataFromPhoto:photo
                                       originalMetadata:metadata
                                               location:self.latestLocation
                                                 device:self.currentDevice
                                             lensOption:self.currentLensOption];
}

- (NSDate *)creationDateFromMetadata:(NSDictionary *)metadata {
  // å§”æ‰˜ç»™CMImageProcessor
  return [self.imageProcessor creationDateFromMetadata:metadata];
}

- (CLLocation *)locationFromMetadata:(NSDictionary *)metadata {
  // å§”æ‰˜ç»™CMImageProcessor
  return [self.imageProcessor locationFromMetadata:metadata];
}

#pragma mark - ä»£ç†é€šçŸ¥

- (void)notifyDelegateStateChanged {
  if ([self.delegate respondsToSelector:@selector(cameraManager:
                                                 didChangeState:)]) {
    [self.delegate cameraManager:self didChangeState:self.currentState];
  }
}

#pragma mark - å†…å­˜ç®¡ç†

- (void)cleanup {
  [self stopSession];
  [self stopDeviceOrientationMonitoring]; // åœæ­¢æ–¹å‘ç›‘å¬

  dispatch_async(self.sessionQueue, ^{
    // æ¸…ç†AVFoundationç»„ä»¶
    if (self.captureSession) {
      for (AVCaptureInput *input in self.captureSession.inputs) {
        [self.captureSession removeInput:input];
      }
      for (AVCaptureOutput *output in self.captureSession.outputs) {
        [self.captureSession removeOutput:output];
      }
    }

    // æ¸…ç†é¢„è§ˆå±‚
    dispatch_async(dispatch_get_main_queue(), ^{
      [self.previewLayer removeFromSuperlayer];
      self.previewLayer = nil;
    });

    // æ¸…ç†å…¶ä»–ç»„ä»¶
    self.captureSession = nil;
    self.currentDevice = nil;
    self.deviceInput = nil;
    self.photoOutput = nil;
    self.motionManager = nil; // æ¸…ç†æ–¹å‘ç›‘å¬å™¨

    self.currentState = CameraStateIdle;
  });
}

- (void)dealloc {
  [self cleanup];
}

#pragma mark - å±æ€§è®¿é—®å™¨æ¡¥æ¥

// æ¡¥æ¥åˆ°CMDeviceManagerçš„å±æ€§
- (NSArray<CMCameraLensOption *> *)availableLensOptions {
  return self.deviceManager.availableLensOptions;
}

- (CMCameraLensOption *)currentLensOption {
  return self.deviceManager.currentLensOption;
}

- (void)setCurrentLensOption:(CMCameraLensOption *)currentLensOption {
  [self.deviceManager selectLensOption:currentLensOption];
}

@end
